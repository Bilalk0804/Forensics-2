"""
Malware analysis model — File hashing + PE parsing + YARA scanning.

No external ML model needed; uses deterministic analysis:
  - hashlib  for MD5/SHA1/SHA256
  - pefile   for PE header parsing (optional)
  - yara     for rule-based malware signature matching (optional)
"""

import hashlib
import logging
from pathlib import Path
from typing import Any, Optional

logger = logging.getLogger(__name__)

YARA_RULES_PATH = Path(__file__).resolve().parents[3] / "MODELS" / "yara_rules" / "starter_integrity_rules.yar"

# Suspicious file extensions
SUSPICIOUS_EXTENSIONS = {
    ".exe", ".dll", ".bat", ".cmd", ".ps1", ".vbs", ".js",
    ".scr", ".pif", ".com", ".hta", ".wsf", ".msi",
}


class MalwareModel:
    """File-based malware analysis with hashing, PE parsing, and YARA."""

    def __init__(self):
        self.yara_rules = None
        self.pefile_available = False

        # ── YARA rules ──────────────────────────────────────────
        try:
            import yara

            if YARA_RULES_PATH.exists():
                self.yara_rules = yara.compile(filepath=str(YARA_RULES_PATH))
                logger.info("✓ YARA rules compiled (%s)", YARA_RULES_PATH.name)
            else:
                logger.warning("✗ YARA rules file not found at %s", YARA_RULES_PATH)
        except ImportError:
            logger.warning("✗ yara-python not installed — YARA scanning disabled")
        except Exception as exc:
            logger.warning("✗ YARA compile error: %s", exc)

        # ── pefile ──────────────────────────────────────────────
        try:
            import pefile as _pf  # noqa: F401
            self.pefile_available = True
            logger.info("✓ pefile available for PE analysis")
        except ImportError:
            logger.warning("✗ pefile not installed — PE analysis disabled")

    # ------------------------------------------------------------------ #
    def predict(self, data: bytes) -> dict:
        """
        Analyse raw file bytes for malware indicators.

        Returns dict with:
            is_malicious, confidence, threat_label, threat_family,
            hashes, pe_info, yara_matches
        """
        hashes = self._compute_hashes(data)
        yara_matches = self._scan_yara(data)
        pe_info = self._parse_pe(data)

        # Determine threat assessment
        is_malicious = len(yara_matches) > 0
        threat_label = "clean"
        threat_family: Optional[str] = None
        confidence = 0.0

        if yara_matches:
            threat_label = yara_matches[0]
            threat_family = yara_matches[0].split("_")[0] if "_" in yara_matches[0] else None
            confidence = min(0.95, 0.6 + 0.1 * len(yara_matches))

        # PE header anomalies boost suspicion
        if pe_info:
            if pe_info.get("is_packed"):
                confidence = max(confidence, 0.7)
                if threat_label == "clean":
                    threat_label = "suspicious-packed"
            if pe_info.get("suspicious_imports"):
                confidence = max(confidence, 0.6)
                if threat_label == "clean":
                    threat_label = "suspicious-imports"

        if confidence > 0.5 and not is_malicious:
            is_malicious = True

        return {
            "is_malicious": is_malicious,
            "confidence": round(confidence, 4),
            "threat_label": threat_label,
            "threat_family": threat_family,
            "hashes": hashes,
            "pe_info": pe_info,
            "yara_matches": yara_matches,
        }

    # ------------------------------------------------------------------ #
    @staticmethod
    def _compute_hashes(data: bytes) -> dict[str, str]:
        return {
            "md5": hashlib.md5(data).hexdigest(),
            "sha1": hashlib.sha1(data).hexdigest(),
            "sha256": hashlib.sha256(data).hexdigest(),
        }

    def _scan_yara(self, data: bytes) -> list[str]:
        if self.yara_rules is None:
            return []
        try:
            matches = self.yara_rules.match(data=data)
            return [str(m) for m in matches]
        except Exception as exc:
            logger.error("YARA scan error: %s", exc)
            return []

    def _parse_pe(self, data: bytes) -> Optional[dict]:
        """Parse PE headers if the file is a Windows executable."""
        if not self.pefile_available:
            return None
        if len(data) < 2 or data[:2] != b"MZ":
            return None
        try:
            import pefile

            pe = pefile.PE(data=data, fast_load=True)
            pe.parse_data_directories()

            # Suspicious imports
            suspicious_apis = {
                "VirtualAlloc", "VirtualProtect", "WriteProcessMemory",
                "CreateRemoteThread", "NtUnmapViewOfSection", "LoadLibraryA",
                "GetProcAddress", "URLDownloadToFileA",
            }
            found_imports = set()
            if hasattr(pe, "DIRECTORY_ENTRY_IMPORT"):
                for entry in pe.DIRECTORY_ENTRY_IMPORT:
                    for imp in entry.imports:
                        if imp.name:
                            name = imp.name.decode("utf-8", errors="ignore")
                            if name in suspicious_apis:
                                found_imports.add(name)

            # Entropy check (packed binaries have high entropy)
            sections = []
            is_packed = False
            for section in pe.sections:
                entropy = section.get_entropy()
                name = section.Name.decode("utf-8", errors="ignore").strip("\x00")
                sections.append({"name": name, "entropy": round(entropy, 2), "size": section.SizeOfRawData})
                if entropy > 7.2:
                    is_packed = True

            pe.close()

            return {
                "sections": sections,
                "is_packed": is_packed,
                "suspicious_imports": sorted(found_imports),
                "num_sections": len(sections),
            }
        except Exception as exc:
            logger.debug("PE parse error: %s", exc)
            return None
